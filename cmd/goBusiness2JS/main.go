package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"
)

func main() {
	// Hardcoding the file path for now
	filepath := "../../examples/signup/business/index.go"
	// Check if the file exists
	if _, err := os.Stat(filepath); os.IsNotExist(err) {
		fmt.Printf("File does not exist: %s\n", filepath)
		return
	}

	fset := token.NewFileSet()

	// Parse the Go source file
	f, err := parser.ParseFile(fset, filepath, nil, parser.ParseComments)
	if err != nil {
		fmt.Println("Error parsing file:", err)
		return
	}

	var globals []string
	var functions []string

	// Collect global variables
	for _, decl := range f.Decls {
		if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.VAR {
			for _, spec := range genDecl.Specs {
				if valueSpec, ok := spec.(*ast.ValueSpec); ok {
					for _, name := range valueSpec.Names {
						globals = append(globals, name.Name)
					}
				}
			}
		}
	}

	// Collect function names and their parameters
	for _, decl := range f.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok {
			// Only export top-level functions (no methods)
			if funcDecl.Recv == nil {
				// Append function name and its parameters
				functions = append(functions, funcDecl.Name.Name)
			}
		}
	}

	// Generate JS module
	var sb strings.Builder
	sb.WriteString("// AUTO-GENERATED by go-to-js-exporter\n")
	sb.WriteString("// Exports Go globals as null and functions as placeholders\n\n")

	// Export functions as dummy functions with parameters
	for _, fn := range functions {
		// Find the function declaration in the AST
		var funcDecl *ast.FuncDecl
		for _, decl := range f.Decls {
			if d, ok := decl.(*ast.FuncDecl); ok && d.Name.Name == fn {
				funcDecl = d
				break
			}
		}

		// Extract parameters from function signature
		var paramNames []string
		if funcDecl != nil && funcDecl.Type.Params != nil {
			for _, param := range funcDecl.Type.Params.List {
				for _, name := range param.Names {
					paramNames = append(paramNames, name.Name)
				}
			}
		}

		// Create the function signature in JS (with parameters)
		sb.WriteString(fmt.Sprintf("export function %s(%s) {\n", fn, strings.Join(paramNames, ", ")))
		sb.WriteString(fmt.Sprintf("  throw new Error(\"%s is a placeholder function.\");\n", fn))
		sb.WriteString("}\n\n")
	}

	// Print the generated JS code to stdout
	fmt.Print(sb.String())
}
