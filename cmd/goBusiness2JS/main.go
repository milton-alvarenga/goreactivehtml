package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"
)

func main() {
	// Hardcoding the file path for now
	filepath := "../../examples/signup/business/index.go"
	bff := "\"/signup/business\""
	// Check if the file exists
	if _, err := os.Stat(filepath); os.IsNotExist(err) {
		fmt.Printf("File does not exist: %s\n", filepath)
		return
	}

	fset := token.NewFileSet()

	// Parse the Go source file
	f, err := parser.ParseFile(fset, filepath, nil, parser.ParseComments)
	if err != nil {
		fmt.Println("Error parsing file:", err)
		return
	}

	var globals []string
	var functions []string

	// Collect global variables
	for _, decl := range f.Decls {
		if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.VAR {
			for _, spec := range genDecl.Specs {
				if valueSpec, ok := spec.(*ast.ValueSpec); ok {
					for _, name := range valueSpec.Names {
						globals = append(globals, name.Name)
					}
				}
			}
		}
	}

	// Collect function names and their parameters
	for _, decl := range f.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok {
			// Only export top-level functions (no methods)
			if funcDecl.Recv == nil {
				// Append function name and its parameters
				functions = append(functions, funcDecl.Name.Name)
			}
		}
	}

	// Generate JS module
	var sb strings.Builder
	sb.WriteString("// AUTO-GENERATED by go-to-js-exporter\n")
	sb.WriteString("// Exports Go globals as null and functions as placeholders\n")

	sb.WriteString("import {wsconn} from './lib/ws/conn.js;\n\n")

	sb.WriteString(fmt.Sprintf("let bff=%s;\n\n", bff))

	//Create globals variable as null right now, not initialized with zero of its type
	for _, nm := range globals {
		// Create the variable in JS
		sb.WriteString(fmt.Sprintf("let _%s = null;\n", nm))
	}

	if len(globals) > 0 {
		//Generate space between variables and functions generated
		sb.WriteString("\n")
	}

	//@TODO The JavaScript code is almost correct, but you should ensure that after calling sync(), the internal variables are updated.
	if len(globals) > 0 {
		sb.WriteString("function sync(var_nm,v){wsconn.requestRPC(bff,'$$sync',{[var_nm]:v},null).then(() => eval(`_${var_nm} = v`)),(error) => console.log(error)); return v}\n\n")
	}

	//Create globals variable as null right now, not initialized with zero of its type
	for _, nm := range globals {
		// Create the variable in JS
		sb.WriteString(fmt.Sprintf("export const %s = (value) => arguments.length === 0 ? _%s : (_%s != value) ? sync(%s,value) : value;\n", nm, nm, nm, nm))
	}

	if len(globals) > 0 {
		//Generate space between variables and functions generated
		sb.WriteString("\n")
	}

	// Export functions as dummy functions with parameters
	for _, fn := range functions {
		// Find the function declaration in the AST
		var funcDecl *ast.FuncDecl
		for _, decl := range f.Decls {
			if d, ok := decl.(*ast.FuncDecl); ok && d.Name.Name == fn {
				funcDecl = d
				break
			}
		}

		// Extract parameters from function signature
		var paramNames []string
		if funcDecl != nil && funcDecl.Type.Params != nil {
			for _, param := range funcDecl.Type.Params.List {
				for _, name := range param.Names {
					paramNames = append(paramNames, name.Name)
				}
			}
		}

		// Create the function signature in JS (with parameters)
		sb.WriteString(fmt.Sprintf("export function %s(%s) {\n", fn, strings.Join(paramNames, ", ")))

		// Start the params object
		sb.WriteString("  let params = {")

		for i, param := range funcDecl.Type.Params.List {
			for _, name := range param.Names {
				// Add a comma between fields (but not before the first one)
				if i > 0 {
					sb.WriteString(",")
				}
				sb.WriteString(fmt.Sprintf("\"%s\":%s", name.Name, name.Name))
			}
		}

		sb.WriteString("};\n") // Close the params object

		//@TODO Need to see how to return the value of the processment
		sb.WriteString(fmt.Sprintf("  return wsconn.requestRPC(bff,'%s',params,null);\n", fn))

		sb.WriteString("}\n\n")
	}

	// Print the generated JS code to stdout
	fmt.Print(sb.String())
}
