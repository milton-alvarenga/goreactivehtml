package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"strings"
)

func main() {
	/*
		if len(os.Args) < 2 {
			fmt.Println("Usage: go run main.go <path-to-go-source>")
			return
		}
		filepath := os.Args[1]
	*/
	filepath := "../../examples/signup/business/index.go"

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filepath, nil, parser.ParseComments)
	if err != nil {
		fmt.Println("Error parsing file:", err)
		return
	}

	var globals []string
	var functions []string

	// Collect global variables
	for _, decl := range f.Decls {
		if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.VAR {
			for _, spec := range genDecl.Specs {
				if valueSpec, ok := spec.(*ast.ValueSpec); ok {
					for _, name := range valueSpec.Names {
						globals = append(globals, name.Name)
					}
				}
			}
		}
	}

	// Collect function names
	for _, decl := range f.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok {
			// Only export top-level functions (no methods)
			if funcDecl.Recv == nil {
				functions = append(functions, funcDecl.Name.Name)
			}
		}
	}

	// Generate JS module:
	var sb strings.Builder

	sb.WriteString("// AUTO-GENERATED by go-to-js-exporter\n")
	sb.WriteString("// Exports Go globals as null and functions as placeholders\n\n")

	/*
		// Export globals as const null
		for _, g := range globals {
			sb.WriteString(fmt.Sprintf("export const %s = null;\n", g))
		}
		sb.WriteString("\n")
	*/
	// Export functions as dummy functions throwing errors
	for _, fn := range functions {
		sb.WriteString(fmt.Sprintf("export function %s() {\n", fn))
		sb.WriteString(fmt.Sprintf("  throw new Error(\"%s is a placeholder function.\");\n", fn))
		sb.WriteString("}\n\n")
	}

	// Print the generated JS code to stdout
	fmt.Print(sb.String())
}
